from langchain_ollama import OllamaEmbeddings
from langchain_ollama import ChatOllama
from langchain_chroma import Chroma
from langchain_core.prompts import PromptTemplate
import json

from pathlib import Path

class RagAgent:
    """
    A class representing agent responsible for RAG over vector database

    Attributes
    ----------
    persist_dir: str
        Location of the Vector DB
    embeddings: OllamaEmbeddings
        Embedding model for the Vector DB
    vector_store: Chroma
        Vector DB for storig the reviews
    retriever: 
        Chroma DB retriver
    llm : ChatOllama
        Instance of LLM
    db_filter_prompt : PromptTemplate
        Template of prompt to create Chroma DB filter for the vector search
    correct_filter_prompt : PromptTemplate
        Template of prompt to check the created filter before execution
    
    Methods
    -------
    needs_filtering(question: str)
        Check with the LLMdetermine if the user query requires a filter and generates one if needed
    
    correct_query(query_draft: str, output_format: str)
        Check if the query generated by the initial LLM is valid, formats it in a valid Chroma DB query format
    
    def run(self, question: str)
        Executes RAG workflow
    """
    def __init__(self):
        persist_dir = Path(__file__).resolve().parent.parent / "database" / "chroma_db"
        self.embeddings = OllamaEmbeddings(model="snowflake-arctic-embed:33m")
        self.vector_store = Chroma(
            collection_name="ecommerce_reviews",
            embedding_function=self.embeddings,
            persist_directory=str(persist_dir),
        )
        self.retriever = self.vector_store.as_retriever(search_kwargs={"k": 10})

        self.llm = ChatOllama(model="mistral:7b", 
                 temperature=0,
                 seed=42)

        self.db_filter_prompt = PromptTemplate.from_template(
            """You are a smart assistant. Your job is to construct the most suitable yet simple filter to answer the user question.

            Database fields to filter: 
            'clothing_id': id of item that is reviewed; int [0,1205]
            'age': age of the review author; int [18,99]
            'rating': rating the reviewer gave to the product; int [1,5]
            'division_name': high level store division; str ['general', 'general petite', 'initmates']
            'department_name': product department name; str ['tops', 'dresses', 'bottoms', 'intimate', 'jackets', 'trend']
            'class_name': product type; str ['intimates', 'dresses', 'pants', 'blouses', 'knits', 'outerwear', 'lounge', 'sweaters', 'skirts', 'fine gauge', 'sleep', 'jackets', 'swim', 'trend', 'jeans', 'legwear', 'shorts', 'layering', 'casual bottoms', 'chemises']

            Question: {question}

            Do not propose filters that include entire range of values 
            Wrong answer example: rating=1,2,3,4,5 explaantion: rating is always a number in range 1-5
            
            If it doesn't require filtering answer "no_filter_needed".

            Propose a filter construction in Chroma DB Query Language.
            Filter may not be necesairy for some question, if base do not require filtering answer "no_filter_needed"
            
            Do not provide any further explanation only the filter or no_filter_needed.

            Your answer need to be unambiguous decision.
            """
            
        )


        self.correct_filter_prompt = PromptTemplate.from_template(
            """Your job is to prepare a Chroma DB syntax for filtering.
            Never change names of key and value only strip any additional data and organize as a valid query.

            Query draft (potentially in incorrect format):
            {query_draft}
            Return only the correct query filter and no further explanation.

            Desired output format:
            {output_format}

            Query draft is correct return it unchanged.

            You can output only ONE filter so if multiple items are included use and / or operator to produce ONE valid filter!
            Answer ONLY with JSON WITH QUERY FILTER in Chroma DB Query Language.
            Your answer need to be unambiguous decision.
            Chroma db expects to have exactly one operator in query!
            """
        )

    def needs_filtering(self, question):
        """
        Check with the LLM if the user query requires filter, and produces one if needed

        Parameters
        ----------
        question : str
            User input question

        Returns
        -------
        str
            Returns filtering proposition or 'no_filter_needed'
        """
        db_filter_chain = self.db_filter_prompt | self.llm 
        return db_filter_chain.invoke({"question" : question}).content
    
    def correct_query(self, query_draft, output_format):
        """
        Checks if the query proposed by first LLM is valid, formats it in a valid Chroma DB output format

        Parameters
        ----------
        query_draft: str
            Query proposition from the previous LLM
        question : str
            User input question

        Returns
        -------
        str
            Corrected query
        """
        correct_filter_chain = self.correct_filter_prompt | self.llm 
        return correct_filter_chain.invoke({"query_draft" : query_draft, "output_format":output_format}).content.strip()
    
    def query_vectorstore(self, question, filter_db):
        parsed_json = json.loads(filter_db)
        results = self.retriever.invoke(question, filter=parsed_json)
        return results

    
    def run(self, question):
        """
        Runs the RAG workflow: suggests and refines filters based on user input, executes vector search,
        and returns the combined final answer as a string
        
        Parameters
        ----------
        question : str
            User input question

        Returns
        -------
        str
            Text of relevant reviews retrieved with vector search
        """

        retrived_content = ""

        filtering = self.needs_filtering(question)

        if not "no_filter_needed" in filtering:
            output_format = """
            Output message in this format if filter consists of one column:
            {"column_1": {"$eq": "Value_1"}}

            Output message in this format if filter consists of multiple columns:
            {"$and": [
                {"column_1": {"$eq": "Value_1"}},
                {"column_2": {"$eq": "Value_2"}}
                ]
            }
            
            WARNING
            Chroma db expects to have exactly one operator in query!
            """
            filter_db = self.correct_query(filtering, output_format)

            print(filter_db)
            
            try: 
                results = self.query_vectorstore(question, filter_db)
                print("filter used")
            except:
                results = self.retriever.invoke(question)
                print("filter not used - error")

        else:
            results = self.retriever.invoke(question)
            print("filter not used")

        for res in results:
            retrived_content += f" - {res.page_content} \n"
   
        return retrived_content